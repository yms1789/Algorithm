## 🌀 이차원 배열과 연산

- 문제 유형(목록): 구현, 시뮬레이션, 정렬(백준)
- solution
  - 배열의 값과 값이 나오는 개수를 세기 위해 `Map`을 사용
    - `map.compute(값, (number, count) -> count == null ? 1 : count + 1);`
  - map의 값들을 정렬하기 위해 우선순위 큐를 사용해서 count가 큰 숫자가 앞으로 오게끔 함
    - 만약 count가 같다면 숫자가 큰 값이 앞으로 오게끔 정렬
  - 이차원 배열의 행이 열 개수보다 크거나 같다면?
    - 우선순위 큐가 빌 때 까지 큐에 있는 값들을 열을 1씩 증가시키면서 이차원 배열에 넣어줌
  - 반대로 열의 개수가 더 많다면
    - 우선순위 큐가 빌 때 까지 큐에 있는 값들을 행을 1씩 증가시키면서 이차원 배열에 넣어줌
  - 값을 다 넣어주고 남은 배열 공간은 0으로 채워줌

## 🌀 무선 충전

- 문제 유형(목록): 구현, 시뮬레이션, 중복조합(SWEA)
- solution
  - 유저 A, B를 매 초마다 이동시키면서 무선충전 범위 내에 있다면 최대 충전량을 구해서 M초까지 이동했을 때 총 충전량을 구하는 문제
  - 단, 유저 A와 B가 무선충전기 범위 내에 같이 속해있다면 두 인원을 잘 쪼개서 최대가 되게끔 해줘야 함
    - 위 문제를 해결하기 위해 어떻게 해야할 지 감이 오지 않아서 결국 답을 봄...
    - 다른 사람의 풀이를 보니 중복조합을 통해 유저 A와 B가 이동했을 때의 무선 충전량의 모든 경우를 다 도출해내서 최대 값을 찾음
    - 이중 for문을 사용해서 유저 A가 무선충전 범위 내에 속한다면 B도 해당 무선충전기 범위 내에 속하는지 확인
      - 둘 다 같은 무선충전기 범위에 속하면 충전량을 1번만 temp에 더해줌
      - 아니면 각각 속해있는 무선충전기의 충전량을 temp에 더해줌
    - 유저 A는 무선 충전기 범위 내에 속하지 않고 B만 속해있다면 B가 속해있는 무선충전량을 temp에 더해줌
    - 위에서 도출해낸 모든 경우의 수를 `Math.max()`메서드를 사용해서 최대값을 도출 ⇒ 매 초마다의 최대값을 `res`에 더해준 뒤 `res` 출력

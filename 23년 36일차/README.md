## 🌀 숨바꼭질

- 문제 유형(목록): 그래프, 너비 우선 탐색(백준)
- solution
  - 수빈이의 현재 위치에서 시작해서 BFS를 통해 걸을 때와 순간이동 할 때 다음 수빈이 위치에 현재 위치 + 1만큼의 시간을 저장
  - 만약 수빈이가 동생 위치에 도달하게 되면 동생 위치(`map[K]`)에 현재 위치 + 1 한 값을 출력
  - 헤맸던 부분
    1. 입력 값이 같을 때(수빈이 위치와 동생 위치가 처음부터 같은 걸 고려 X)
    2. 배열 크기가 최대 100,000인데 줄여보겠다고 `N + K + 1`로 해서 제출하니까 틀렸다고 나왔다...

## 🌀 뒤에 있는 큰 수 찾기

- 문제 유형(목록): 자료구조, 스택(프로그래머스)
- solution
  - 처음엔 i번째 수 뒤에 있는 수를 `slice`를 사용해 배열로 만든 후 해당 배열을 순회하면서 `find` 메서드로 i번째 숫자보다 큰 값을 찾아서 리턴
  - 만약 리턴 값이 없다면(`undefined`)라면 -1을 `push`
    ⇒ 시간초과!(numbers 배열 길이가 최대 1,000,000이므로 최악의 경우 100만 \* 100만의 시간복잡도가 나타남)
  - 해결
    - 다른 사람들의 코드를 참조 ⇒ stack 자료구조를 통해 해결
    - stack에 인덱스 값을 넣어놓고 현재 숫자(numbers[i])보다 스택의 가장 상단에 있는 인덱스 숫자(`numbers[stack[stack.length - 1]]`)랑 비교
      - 현재 숫자가 더 크면 answer를 현재 숫자로 바꿔주고 스택에서 해당 인덱스를 제거하는 방식

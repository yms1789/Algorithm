## 🌀 숫자고르기

- 문제 유형(목록): 백트래킹, 깊이 우선 탐색(백준)
- solution
  - 초기 구현
    - BFS를 사용해서 Queue에 좌표값을 넣고 4방향을 방문처리 해나감
    - 해당 칸이 board를 벗어나거나 이미 방문했거나, 알파벳리스트에 이미 있는 알파벳이라면 `continue`
    - 위 경우에 해당하지 않는다면 알파벳 리스트에 해당 칸 알파벳을 추가
    - 문제점: 예제 3번에서의 알파벳 리스트
      - 첫번째 순회: [I, F, E]
      - 두번째 순회: [I, E, F ,H] → `board`의 (0, 0) ~ (1, 3) 까지만 진출 가능
      - 백트래킹을 통해 알파벳 리스트도 되돌려 줄 필요가 있음!
  - 해결방식: DFS를 통해 해결
    - 입력받은 알파벳을 숫자(`input - 'A'`(0 ~ 25))로 바꾼뒤 `visited`의 인덱스를 알파벳의 숫자로 처리
    - visited가 `true`라면(이미 해당 알파벳을 방문한 적 이 있다!) 기존에 지나온 칸 수(`res`)와 현재 칸 수(`count`) 중 큰 수를 res에 할당
    - 아직 해당 칸을 방문 안했다면 방문 처리해 준 후 해당 칸에서 4방향을 순회하면서 방문처리 안 된 칸이 있는지 확인
      - 방문처리해 준 칸은 다시 `false`로 해서 다시 되돌아와서 순회 가능하게끔 함
    - 위 과정을 재귀를 통해 계속 반복하면서 가장 많이 이동한 경우를 출력
## 🌀 문자열 폭발

- 문제 유형(목록): 스택, 문자열(백준)
- solution
  - 초기 접근
    - 반복문을 돌면서 스택에 입력받은 문자열을 1문자씩 집어 넣음
    - 스택의 가장 위에 있는 값이 폭탄 문자열의 첫번째 값과 같으면
      - 해당 문자 인덱스 + 폭탄문자열 길이가 전체 문자열 인덱스를 벗어나는지 확인해서 벗어나면 폭탄문자열이 아니므로 해당 인덱스 `push`후 `continue`
      - 스택의 끝 값 + 폭탄 문자열 길이만큼의 나머지 문자열이 폭탄 문자열과 같은지 확인
        - 같다면 스택의 끝 값을 빼주고 idx를 폭탄 문자열 길이 - 1만큼 더해줌
    - 인덱스 값이 전체 문자열 길이와 같아지면 반복문을 빠져나감
    - 스택에 있는 값을 `StringBuffer`에 넣어준 후 `StringBuffer.toString()` 메서드로 출력
    - 스택이 비었다면 FRULA 출력
    - 문제점: 폭탄 문자열 길이가 1일 때 마지막 push가 폭탄 문자열이랑 같다면 이 부분을 처리해주지 못함
      - ex) `INPUT: AABBB, BOMB: B ⇒ OUTPUT: AA, 코드 결과: AAB`
  - 해결 방법
    - 스택에 폭탄문자열 길이만큼의 값이 들어 갔을 때 스택에 들어가있는 문자(끝에서 부터 폭탄 문자열 길이만큼)를 폭탄 문자열과 하나씩 비교
    - 만약 전부 같다면(`flag = true`) 폭탄 문자열 길이만큼 `stack`에서 `pop`
    - 문자열 길이만큼 반복문 순회한 후 스택에 남아있는 값이 없다면 FRULA, 있다면 문자열로 치환해서 출력

## 🌀 큰 수 만들기

- 문제 유형(목록): 자료구조, 스택(프로그래머스)
- solution
  - 초기 접근
    - 조합을 이용해서 `number`에서 `k`개를 제외한 나머지를 뽑은 후 가장 큰 값을 찾자!
    - 주어진 `number` 문자열 길이가 `1 <= number.length <= 1,000,000` 이라서 조합을 이용한 접근 방식 X
    - 구글링을 통해 스택을 사용하면 해결 가능하다는 것을 확인함
    - `answer` 스택이 비었다면 `number`의 `i`번째 문자열을 삽입
    - `k`가 0보다 크다면(아직 숫자 제거를 덜 했다면)
      - 스택의 마지막 값이랑 number의 i번째 인덱스 값이랑 비교
        - 스택의 마지막 값이 더 작으면 스택이 number의 i번째 인덱스 값보다 클 때까지 스택에서 제거, `k -= 1`
        - 제거하면서 `answer`이 비거나 `k`가 0이하인 경우는 더 이상 제거해줄 값이 없으므로 `break`
    - 위 두 조건에 해당하지 않으면 `answer`에 `i`번째 `number`를 `push`

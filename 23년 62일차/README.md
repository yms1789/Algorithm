## 🌀 소가 길을 건너간 이유

- 문제 유형(목록): dfs, bfs(백준)
- 초기 구현
  - 소를 두개 선정(조합)
  - 첫번째 소 위치 → 두번째 소 위치까지 이동하면서 길을 건넜는지 안건넜는지 판단(bfs)
    - 길을 안 건넜다면 `return true`
    - 길을 건넜다면 `return false`
  - `false`인 경우만 `count++`
  - 길을 건넜는지 판단 여부는 (r, c, r', c')을 문자열로 만들어서 `roads`에 `push`
    - bfs과정에서 현재 위치(cx, cy), 다음 위치(nx, ny)를 문자열로 만들어서 길인지 판단
  - 시간초과
- Solution
  - 2개 소를 선정해서 A → B까지 갈 때 길을 건넜는지 여부를 판단하지말고, 길을 건너지 않았을 때 A위치에 있는 소가 B까지 갈 수 있는지를 판단
  - 소를 1마리 선정, bfs를 돌려서 길을 건너는 경우는 continue 길을 안 건너고 갈 수 있는 모든 위치를 `true`로 만들어 준 후 남은 소들의 위치에 도달할 수 없다면(반드시 길을 건너야 한다면) `count++`
    - 길인지 여부는 기존 방식과 동일
  - 여전히 시간초과...
- Solution2
  - 길인지 판단을 다른 방식으로 하자(이 부분에서 시간초과가 날 듯해서)
  - 기존: 두 목초지를 문자열로 만들어서 roads에 저장((r,c,r',c', r',c',r,c))
  - 수정: 목초지의 시작 지점에 끝 지점을 저장하고, 끝 지점에 시작지점을 할당
    - `roads[r][c].push(roads[_r][_c].join(""))`, `roads[_r][_c].push(roads[r][c].join(""))`
  - 기존에는 모든 길을 include를 통해 비교했다면 수정한 코드에서는 특정 목초지에 있는 값만 비교하면 되므로 시간을 줄일 수 있었음
  - **주의**
    - javascript에서 `Array.from({ length: N + 1 }, () => Array(N + 1).fill([]))` 요렇게 배열을 만들면 하위 배열이 복제되는 것이 아니라 같은 배열을 참조하게 됨

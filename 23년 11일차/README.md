## 🌀 스티커

- 문제유형(목록): DP(백준)
- Solution
  - `dp[i]`는 i번째 고르기 전 스티커의 최대 점수
  - 스티커는 자신을 기준으로 상하좌우를 선택할 수 없는 제한이 있음
  - 그렇다면 스티커를 하나 선택했을 때 대각선으로 갈 수 밖에 없음
  - (0, 1) 스티커를 뗀다면 -> (0, 2), (1, 1)은 사용 불가
  - (1, 1) 스티커를 뗀다면 -> (0, 1), (1, 2)는 사용 불가
  - (1, 2) 위치를 뗀다면? -> (1, 1), (0, 2), (1, 3)은 사용 불가
    - 가장 스티커의 합이 커지는 경우는 (0, 1), (1, 2)를 뗄 때!
  - (0, 3) 위치를 뗀다면?
    - (0, 1) + (1, 2) + (0 , 3) or (1, 1) + (0, 3) 두 가지 경우 가능
  - 즉, 특정 위치를 뗐을 때 최대가 되려면 => MAX(특정 위치의 왼쪽 대각선, 특정 위치의 왼쪽 대각선의 왼쪽) + 현재 위치를 비교하면 됨

## 🌀 점프

- 문제유형(목록): DP(백준)
- Solution
  - 참고: [풀이](https://hu-coding.tistory.com/36)
  - i, j칸에 도착하게 되는 경로의 개수를 `dp[i][j]`라고 하면
  - `arr[i][j]` 에서 다음 이동 칸은 `arr[i + arr[i][j]][j] or arr[i][j + arr[i][j]]`
  - 다음으로 도착하게 되는 칸에 이전 칸 까지 오는 경로의 수를 더해주면 됨
    즉, `dp[i + next][j] += dp[i][j]` or `dp[i][j + next] += dp[i][j]`
    - 단, `i + next, j + next <= N` 이어야 함

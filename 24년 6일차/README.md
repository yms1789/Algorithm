## 🌀 빗물

- 문제 유형(목록): 구현, 시뮬레이션(백준)
- 혼자 힘으로 풀었는지 여부: ⭕️
- Solution
  - 맨 왼쪽부터 2차원 세계의 가로까지 이동하면서 현재 위치에서 양쪽 끝에 있는 블록들의 개수를 파악하자
  - 그 다음 왼쪽에 쌓여 있는 블록 중 가장 높이 쌓인 블록 수, 오른쪽에 쌓여 있는 블록 중 가장 높이 쌓인 블록 수를 저장
  - 저장한 왼쪽, 오른쪽 블록 개수 중 더 낮은 블록 수를 인덱스마다 찾자
  - 이 때, 현재 인덱스에 블록이 쌓여 있을 수 있으니까 찾은 블록 수에서 현재 쌓여 있는 블록 수를 뺀 값을 더해나가자
  
  - 예시
    - 힌트 2에서 현재 2번째 칸에 빗물이 얼마나 고일지를 판단한다고 했을 때 왼쪽에 있는 블록 중 가장 높이 쌓인 블록은 3, 오른쪽은 4
    - 그럼 해당 인덱스에 고이는 빗물 높이는 높아봤자 3이 최대
    - 이 때, 2번 인덱스에는 현재 블록이 1개 쌓여 있으니까 3 - 1 = 2만큼의 빗물이 고이게 됨

- 이전에 Java로 풀었을 땐 2차원 배열로 입력받아서 각 인덱스마다 좌, 우에 벽이 있는지 판단해서 해당 인덱스에 물이 고일 수 있는지 판단함

- _다른 사람 풀이_
  - 시간 복잡도가 더 작게 푼 사람들을 확인해보면 대부분 투포인터를 이용해서 풀었음
  - `l` = 시작점, `r` = 끝점으로 두고 한 칸씩 이동시키면서 빗물이 얼마나 고일지 측정

## 🌀 기차가 어둠을 헤치고 은하수를

- 문제 유형(목록): 구현, 비트마스킹(백준)
- 혼자 힘으로 풀었는지 여부: ⭕️
- Solution
  - 명령어가 1, 2번이면 2차원 배열에 승객을 태우거나(1) 하차시킴(0)
  - 명령어가 3, 4번이면 승객을 한 칸씩 뒤로 밀거나 앞으로 당겨야 함
    - 큐처럼 앞으로 당겨야하면 가장 첫번째 승객을 빼고 가장 뒤에 한자리를 0으로 채움
    - 마찬가지로 뒤로 밀어야 하면 가장 뒤 승객을 빼고 맨 앞에 한 자리를 0으로 채움
  - 명령 후에 2차원 배열을 문자열로 `join`한 후 `Set`을 통해 중복제거한 뒤 은하수를 건널 수 있는 기차 수를 구함

*푼 문제였는데 풀었던 기억이 안나서 다시 품*

## 🌀 가르침

- 문제 유형(목록): 비트마스킹, 백트래킹, 브루트포스(백준)
- 혼자 힘으로 풀었는지 여부: ❌
- 유의사항
  - 선생은 K개의 단어만 가르칠 수 있고 학생들은 K개의 글자로 이루어진 단어만 읽을 수 있음
  - 이 때, 남극언어는 접두어(anta)와 접미어(tica)가 반드시 단어에 포함됨
  - 그래서 결과적으로 선생님은 학생들에게 K - 5개의 글자만 가르칠 수 있음
  - K - 5개의 글자를 가르쳐서 최대한 많은 단어를 읽을 수 있도록 해야함
- 초기 접근
  - 남극언어는 미리 세팅해두고 주어진 언어들에서 남극언어가 아닌 글자들만 뽑아내서 중복 제거
  - dfs를 통해 K - 5개의 가르칠 글자를 선택
  - 주어진 단어가 가르친 글자만 사용해서 읽을 수 있는 단어인지 판단
    - 단어 알파벳이 가르친 글자에 포함되는지 판단(`choice.includes(del[j])`)
    - 만약 단어에 안 가르친 글자가 존재하면 아무것도 하지않고 단어 알파벳들이 모두 가르친 글자라면 `readCnt++`
  - 위 과정을 반복해서 가장 많이 단어를 읽을 수 있는 경우를 찾아냄
  - 문제점
    - **시간초과**
    - 재귀문이 실행되면서 이중 for문 * `includes()`까지 사용해서 시간초과가 난 듯함
- Solution
  - **`includes()`를 사용하지 않고 알파벳 리스트를 만들어서 가르친 단어들을 `true`로 만들고 `charCodeAt()`을 사용해서 단어 내 특정 알파벳이 가르친 알파벳인지 아닌지 판단**
    - 기존에는 접두어, 접미어를 자른 후 남은 알파벳들만 판단했으나 알파벳 리스트를 미리 세팅해놨으므로 굳이 불필요한 연산을 할 필요가 없어짐
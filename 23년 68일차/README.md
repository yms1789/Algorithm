## 🌀 풍선 터트리기

- 문제 유형(목록): 투 포인터(프로그래머스)
- 초기 구현
  - 번호가 작은 풍선을 터트리는 행위는 딱 한번만 가능함(나머지는 큰 번호 터트려야 함)
    ➡︎ 배열 중 가장 작은 값이 아닌 어떤 값을 마지막까지 남기려면 한 번의 기회로 배열 내 가장 작은 값을 터트려야 함
  - 즉, 가장 작은 값의 오른쪽 부분은 가장 작은 값을 가진 풍선이 다 터트릴 수 있음
  - 반복문을 통해 가장 왼쪽 풍선부터 순회
    - 다음 풍선이 현재 풍선보다 더 작다면 가장 작은 값을 가진 풍선이 다음 풍선까지 다 터트려 줌 ➡︎ 해당 풍선, 가장 작은 풍선 두 개 남았을 때 가장 작은 풍선 터트리면 해당 풍선을 살릴 수 있다.(`answer + 1`)
    - 다음 풍선이 더 크면 아무리 터트려도 해당 풍선을 터트릴 수 없음
  - 위 과정을 가장 작은 풍선이 있는 인덱스까지 반복하려 함
- 런타임 에러... (길이 100만 배열을 전개연산자 이용해서 `Math.min(...a)` 하려니까 에러가 난다.)
- Solution
  - 투 포인터로 좌, 우측 값과 인덱스를 저장해놓고 좌, 우측 값의 최소값 갱신해나가면서 `answer + 1`반복
  - 좌측 인덱스가 우측 인덱스보다 같거나 커지면 반복문 중단

## 🌀 추월

- 문제 유형(목록): 구현, 자료구조(백준)
- 초기 구현
  - 나가는 차량을 들어오는 차량 배열에 순서에 맞춰서 배열을 만듦
    - ex) `in: [a, b, c, d], out: [a, c, b, d]` 라면 `priority = [0, 2, 1, 3]`
  - 이후 우선순위 배열의 인덱스랑 요소 값이랑 비교해서 요소 값이 인덱스보다 크면 count를 증가시키도록 함
  - 문제점: `in: [a, b, c, d], out: [d, a, b, c]` 라면 `priority = [3, 0, 1, 2]`
    - 이렇게 되면 d차량만 추월한건데 count = 4가 되어버림
- 두번째 구현
  - 투 포인터로 차량의 우선순위가 감소하는 시점에 `count`를 증가시켜줌
    - ex) `priority = [3, 0, 1, 2]` 라면 3 ➡︎ 0 시점에 `count`증가
    - 문제점 `priority = [0, 6, 2, 3, 4, 5, 1, 7, 8, 9]`라면?
      - 6 ➡︎ 2, 5 ➡︎ 1 두 시점에만 `count`증가 but, 추월한 차량은 6, 2, 3, 4, 5 5대
- Solution
  - 차량 우선순위로 하지말고 나가는 차량 배열 요소를 들어오는 차량 배열 요소랑 비교 어떤 차량이 나갔을 때의 시점이 들어왔을 때랑 다르면 해당 차량은 추월차량이므로 들어온 차량, 나간 차량 배열에서 삭제해주고 다음 차량 비교
    - ex) `in: [a, b, c, d], out: [d, a, b, c]`일 때, d차량이 나간 시점엔 원래 a차량이 나가야 함(추월 차량)
      ➡︎ d차량을 in, out에서 둘 다 삭제 후 다음 차량 확인
    - 위 과정을 반복하면서 추월차량 수를 증가시킴

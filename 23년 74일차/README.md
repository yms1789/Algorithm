## 🌀 도영이가 좋아하는 맛있는 음식

- 문제 유형(목록): 백트래킹, 브루트포스
- Solution

  - 신맛과 쓴맛 재료들을 순서 상관없이 고르자(조합)
  - 고른 재료들의 신맛, 쓴맛 차이를 구한 뒤에 가장 차이가 작은 값을 `diff`에 저장한 뒤(`diff = Math.min(calcTaste(), diff)`) 출력

## 🌀 단축키 지정

- 문제 유형(목록): 구현, 문자열
- Solution

  - 처음에는 순서 1, 2, 3번을 따로따로 적용시켰는데 알고보니 하나의 옵션에 대해 1번이 안되면 2번을 적용시키고 2번도 안되면 3번을 적용시키는 거 였다.
  
  - 단축키로 지정한 알파벳을 저장할 `snippet`배열을 만들고 입력받은 옵션만큼 반복하면서 옵션 단어 별 첫번째 알파벳이 단축키로 지정되어있는지 확인
    - 지정되어있지 않다면 해당 옵션의 알파벳을 대괄호로 감싸준 뒤(문자열은 불변값이기 때문에 문자열을 `split("")`해서 배열로 바꾼 뒤에 진행함) `break`
    - 이 때, 해당 옵션에 1번 순서를 적용시켰는지 여부를 판단해야 하므로 `check` 변수를 두어서 위 과정이 일어나면 `true`로 바꿈
  - check가 true가 아니라면(해당 옵션의 첫 알파벳이 이미 단축키로 모두 지정되어 있다면) 단어의 알파벳을 순회하면서 단축키로 지정되어 있지 않은 알파벳을 찾음
    - 찾은 알파벳역시 대괄호로 감싼 후 `break`
  - 위 2개의 순서에 해당 안되는 옵션이면 가만히 냅두면 됨

## 🌀 미로 탈출하기(다시)

- 문제 유형(목록): 그래프, 깊이 우선 탐색, dp
- 초기 구현

  - 처음엔 단순 bfs라고 생각해서 미로의 각 칸을 시작 지점으로 놓고 탈출할 수 있는지 여부를 판단해서 탈출할 수 있는 칸이면 + 1해서 탈출 가능한 모든 칸 수 출력
    - 시간초과... 단순 bfs로 하면 최악의 경우 250,000 * 250,000의 시간복잡도 (1초 안에 해결 불가)
    - 다른 사람들 풀이를 보니 dp를 통해 미로를 이동하면서 지났던 칸이 빠져 나갈 수 있는 칸인지 아닌지를 메모이제이션 해놓음
- Solution

  - `dp` 배열을 만든 후에 -1로 초기화
    - `dp`에는 3가지 값이 들어갈 수 있음(-1: 아직 안가봄, 0: 탈출 불가, 1: 탈출 가능)
  - 미로 각 칸에 대해 탈출 여부를 판단하는데 현재 위치에서 부터 dfs로 한 칸씩 이동하면서 해당 칸이 이미 가본 칸(`dp[r][c] > -1`)이면 해당 칸은 더 이상 탐색하지 않고 저장된 값을 `return`
  - 저장된 값을 `escapeCnt`에 더해주면서 최종적으로 탈출 가능한 칸 수를 출력
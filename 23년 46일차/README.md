## 🌀 야근 지수

- 문제 유형(목록): 그리디(프로그래머스)
- Solution
  - 초기 접근
    - 야근피로도 = 야근 시작 시점 + 남은 일^2
    - N만큼 남은 시간에서 야근 피로도를 최소화하려면 남은 일을 최대한 작은 수로 만들어야 함
    - works(남은 일 리스트)에서 가장 큰 값을 찾아나가면서 N이 0이 될 때 까지 해당 값을 1씩 줄여주는 일을 반복함
    ```js
    while (n <= 0) {
      let max = Math.max(...works);
      for (let i = 0; i < works.length; i++) {
        if (max === works[i]) {
          works[i]--;
          break;
        }
      }
      n -= 1;
    }
    ```
    - 위 방법대로 하면 max값을 찾는데 드는시간이 최대 2만, n만큼 반복하므로 n의 최대는 100만
      - 시간 복잡도는 O(2만 \* 100만) = O(200억) ⇒ 시간초과!
  - 해결
    - `works.sort()`를 이용해서 리스트를 정렬한다면 가장 끝 값이 최대값이 됨
    - 마찬가지로 n이 0이 될 때까지 반복하면서 내부 for문에서 `max`값보다 크거나 `works[i]`가 크거나 같다면 1씩 빼주고 n도 1씩 빼줌 ⇒ for문 1번 돌 때 max값보다 큰 값을 전부 1씩 감소시킴!
      - 이 방법대로 하면 max값은 여전히 정렬된 배열의 마지막 값이므로 `while`문 내에서 max값을 찾으려고 순회를하지 않아도 된다!

## 🌀 기지국 설치(혼자서 해결 X)

- 문제 유형(목록): 그리디(프로그래머스)
- Solution
  - 초기 접근
    - 기지국을 1개씩 추가시키면서 모든 아파트의 전파가 전달되지 않은 곳이 없을 때 까지 재귀를 통해서 풀려고 함
      - 만약 모든 아파트에 전파가 통하면 종료
    - 문제점: N의 최대가 2억이므로 위 방식대로 하면 시간초과가 무조건 날 것 같았음!
  - 해결방식
    - 다른 사람들의 풀이를 보니까 (1, 첫번째 기지국의 아파트 위치), (마지막 기지국 위치, n) 까지에서 아직 전파가 안통하는 부분을 찾음
    - 기지국 사이 아파트들 중 전파가 안통하는 부분을 찾음
    - 이렇게 전파가 안통하는 아파트의 시작점 ~ 끝점까지의 길이를 구해서 기지국의 최대 전파거리(2 \* w + 1)에 포함되면 기지국을 1개만 증축
    - 최대 전파거리를 넘어서면 `length / (2 * w + 1)`한 값을 올림해서 기지국 개수를 증축함

## 🌀 베스트 앨범

- 문제 유형(목록): 해시(프로그래머스)
- Solution

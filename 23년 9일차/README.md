## 🌀 2 x n 타일링 2

- 문제유형(목록): DP(백준)
- Solution
  - 이전 2 x n 타일링에 2 \* 2 블록이 한 개가 더 추가된 버전
  - `dp[i]` 는 2 \* i 타일링을 만들 수 있는 경우의 수
  - `dp[0] = 0, dp[1] = 2 \* 1`
  - `dp[2]`의 경우의 수
    - 2 \* 2
    - 1 \* 2
    - 2 \* 1
  - `dp[3]`의 경우의 수
    - [2 * 2, 1 * 2], [1 * 2, 2 * 2] : `dp[1]`의 1 * 2 타일에 2 * 2를 양 옆으로 붙인 경우의 수 => `2 * dp[1]`
    - [1 * 2, 2 * 1 2개], [2 * 1 2개, 1 * 2] => `dp[2]`
    - 1 * 1 3개 => `dp[2]`
  - `dp[4]`의 경우의 수
    - 2 \* 2 2개
    - [2 * 2, 2 * 1 2개], [2 * 1 2개, 2 * 2 2개]
    - [2 * 2, 1 * 2 2개], [1 * 2 2개, 2 * 2], [1 *2, 2 * 2, 1 * 2]
    - [1 * 2 2개, 2 * 1 2개], [1 * 2, 2 * 1 2개, 1 * 2], [2 * 1 2개, 1 * 2 2개]
    - 1 \* 2 4개
  - 위 경우의 수 처럼 계속 경우의 수를 세아려보면 `dp[i] = dp[i - 1] + 2 * dp[i - 2]` 라는 점화식을 도출해낼 수 있음

## 🌀 연속합

- 문제유형(목록): DP(백준)
- Solution
  - `dp[i]`는 0 ~ i번째 인덱스까지 중 더했을 때 가장 최대가 되는 부분수열의 합
  - `dp[i]`를 구하려면 이전까지의 합(`dp[i - 1]`) + 현재 인덱스 입력 값과 현재 인덱스 중 더 큰 값을 `dp[i]`에 할당해주면 됨
  - 그 다음 부분 수열(dp)중 가장 큰 값을 리턴하면 연속합이 최대가 되는 값을 구할 수 있음

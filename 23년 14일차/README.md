## 🌀 연구소

- 문제유형(목록): 구현, 그래프(백준)
- Solution
  - 바이러스를 퍼뜨리기 전에 벽 3개를 어떻게 세워야할 지 고민하다가 도저히 생각 안나서
    풀이를 봄
  - dfs를 통해 map의 칸이 빈칸(0)인지 확인하고 빈칸이면 벽을 세움
  - 3칸이상 벽을 세웠으면 bfs로 바이러스를 퍼뜨림
    - 이 때, 원본 배열인 map을 건드리면 벽 위치를 바꾸기 전 상태를 기억하지 못하므로 현재 벽 상태를 복사(deepcopy)
  - 더 이상 퍼뜨릴 수 있는 바이러스가 없을 때 까지 반복했다면 복사한 배열에서 0(안전지역) 개수를 카운팅
  - 위 과정을 반복하면서 가장 안전지대가 많았을 때의 안전지대 수를 출력

## 🌀 n^2 배열 자르기

- 문제유형(목록): 규칙 찾기(프로그래머스)
- Solution
  - 이전 풀이
    - _제한 사항을 생각하지 않았다..._
    - 2차원 배열을 만든 후 BFS를 통해 좌표를 아래, 오른쪽 대각선, 오른쪽으로 움직이면서 기존 값 + 1을 해줌
    - 2차원 배열을 `flat()`을 사용해 1차원 배열로 만든 후 `slice(left, right + 1)` 한 값을 리턴
    - 문제점
      - `n`이 $ 1 \leq n \leq 10^7$ 이므로 2차원 배열을 생성해버리면 메모리 초과(core dump) 발생
  - 해결
    - (x, y)의 배열에 들어가는 숫자가 `Math.max(x, y) + 1` 인 것을 알게됨
    - 1차원 배열의 인덱스를 $n * n$의 2차원 배열의 좌표로 바꾸는 공식 `x = floor(num / n), y = num % n`
      - `num = 5, n = 3` 이라면 2차원 배열에서 `x = floor(5 / 3), y = 5 % 3 => (1, 2)`

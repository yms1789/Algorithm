## 🌀 N과 M(10)

- 문제 유형(목록): 백트래킹
- Solution

  - n개의 입력 중 k개를 고르자
    - 이 때, 오름차순으로 되어있는 부분집합만 골라야 하므로 정렬 후 순서 상관 없이 뽑자(조합) 
  - 고른 부분집합을 `res`에 저장하는 데 고른 숫자 집합이 이미 `res` 배열에 있다면 배열에 추가하지 말자
    - 중복확인 방법: `sub` 배열 원소들을 ","를 포함해서 문자열로 바꾼 후 `res`에 있는지 비교
       `res: ["1,2", "3,4"]`일 때, `sub`를 문자열로 바꾼 값이 "1,2"이면 해당 부분집합은 무시

## 🌀 가장 긴 증가하는 부분 수열 2 (다시)

- 문제 유형(목록): 이분 탐색
- Solution

  - 이분탐색이라는 것을 알고도 스스로 해결하지 못한 문제
  - 입력 배열의 첫번째 인덱스 값을 `lis`배열에 `push`
  - 다음 인덱스부터 반복하면서 lis 배열의 가장 끝에 있는 값보다 입력 배열 현재 인덱스 값이 크다면 `lis`에 `push`
    - 작다면 `lis`배열에 처음 인덱스 값부터 비교하면서 해당 값이 `lis`에 어디에 들어가야할 지 판단해야 함
      - `0 = low, lis의 마지막 인덱스 = hi`로 둔 다음 `lo < hi`를 만족하지 않을 때 까지 반복하면서 `lis`의 중간값보다 작다면 `lo = mid + 1` 크다면 `hi = mid`
        - 반복문이 끝나면 `lis[hi]`인덱스에 현재 값을 할당
      - 즉, `lis`배열에서 현재 값과 가장 가까운 값을 현재 값으로 대치해주면서 가장 긴 부분수열을 만듦
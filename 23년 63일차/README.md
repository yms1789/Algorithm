## 🌀 배열 돌리기 1

- 문제 유형(목록): 구현(백준)
- 초기 구현
  - 가장 바깥쪽 배열(1, 1)부터 가장 안쪽 배열(?)까지 차근차근 반시계방향으로 회
    전 시키자
    - 직사각형 배열 회전이 완료되면 시작 인덱스(init_x, init_y)에서 1씩 더해서안
      쪽 배열로 이동
  - `visited`를 통해 안쪽배열까지 모두 회전시켰는지 판단
  - 결과: **시간초과...**(원인: 배열을 회전시키는 과정에서 기존 배열을 복사함.
    이 과정에서 시간초과가 일어난게 아닐까라는 합리적 의심)
- 해결 방법
  - `Math.min(N, M) / 2` 2차원 배열 행, 열 숫자에 따라 회전시키는 배열 숫자를 찾
    을 수 있었음(ex) (3, 3) 2차원 배열인 경우: 1번, (4, 5) 2차원 배열인 경우: 2
    번)
  - 배열을 회전시킬 때 시작 지점을 저장해놓고 시작 지점을 채워나가는 시점부터 시
    작(위: 오른쪽 → 왼쪽)하면 배열 전체를 복사하지 않고도 회전이 가능함
    - 직사각형 기준 위, 오른쪽, 아래, 왼쪽 순으로 배열을 채워나감
    - 마지막으로 남은 부분(시작 지점 바로 아래 칸)은 시작 지점으로 채워줌
      (`arr[cnt + 1][cnt] = init`)

## 🌀 안전 영역

- 문제 유형(목록): dfs, bfs(백준)
- Solution
  - 입력 배열에서 가장 큰 값을 저장(비가 온다고 했을 때 모든 칸이 잠기는 양)
  - 강수량을 1에서 `maxValue`만큼 반복하면서 bfs를 통해 비에 안 잠긴 인접 칸들의
    영역 수를 구함
  - 강수량에 따라 구한 영역 수의 최대 값을 출력
  - 간과한 점: 모든 영역의 높이가 같을 수 있음(이 때 최대 영역 수는 1(모든 영역
    이 안잠기거나 모두 잠기므로))

## 🌀 A와 B 2

- 문제 유형(목록): 구현, 문자열, 브루트포스, 재귀(백준)
- solution

  - 초기 구현

    - 문자열 S에 재귀를 이용해서 A를 추가했을 때, B를 추가해서 뒤집었을 때 2가지 연산을 시행

      ```js
      recursion(str + "A");
      StringBuffer sb = new StringBuffer();
      sb.append(str + "B");
      sb = sb.reverse();
      recursion(sb.toString());
      ```

      - 시간 초과 발생!

    - 해결
      - 문자열 T에서 A를 제거, B를 제거하고 뒤집기를 하면서 반대로 시행
        - 문자열의 끝이 "A"이면 "A"제거
        - 문자열의 첫번째 인덱스가 "B"이면 "B"제거 후 뒤집기

## 🌀 틱택토

- 문제 유형(목록): 백트래킹, 구현(백준)
- solution
  - 문제 풀 때 유의해야할 조건
    - X 개수랑 O 개수는 최대 한 개 차이가 날 수 있음
    - X가 이겼을 땐 X가 1개 많아야 함
    - O가 이겼을 떈 X 개수 O개수 같아야 함
    - 둘이 비겼을 때도 X, O 개수 같아야 함
  - 처음 풀이: 놓을 칸이 없는 경우와 놓을 칸이 있는 경우로 나눔
    - 놓을 칸이 있을 때 X가 이겼다면 `xCount - oCount = 1`인지 확인
      - O가 이겼다면 `xCount == oCount`인지 확인
    - 놓을 칸이 없다면 최소 비겼거나 X가 이겼어야 함 → O가 이겼으면 `false`
    - 문제점: X, O가 둘 다 이긴 경우는 `invalid`를 출력해야하지만 `valid`가 되어버림
  - 해결
    - 놓을 칸이 있을 때 O와 X가 이겼는지 졌는지를 2번 판단함으로써 둘 다 이겼을 때 `invalid`가 되도록 함
